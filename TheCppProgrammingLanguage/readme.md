# プログラミング言語C++ 第4版

プログラミング言語C++ 第4版のノート



## 参照(Reference)とは

「2.2.5 ポインタと配列と繰返し」で出てくるお話(詳細は「7.7 参照」)  



型宣言時 後ろに"&"指定で 参照(Reference)となる  

ReferenceはC言語にはなかったもの ポインタと似た性質を持つが以下が異なる  

- Referenceは オブジェクトを名前でアクセスする方法と同じ構文で利用できる  
  つまり ポインタxのオブジェクトアクセス時の&xのような指定が不要  
  Reference xはxでオブジェクトを参照できる  
- Referenceは 初期化時の参照先オブジェクトを参照し続ける  
- 空参照(nullptr)は存在しないので 何らかのオブジェクトを参照している前提で処理できる  

Referenceは演算子のオーバーロードをするためにできたらしい  

[ぴよぴよ.py - C++のポインタ渡しと参照渡しの使い分け](http://cocodrips.hateblo.jp/entry/2015/12/08/221722)  

演算子+をオーバライドしたとき 戻り値がポインタだと &x + &y と書かなくてはいけない  

このとき 戻り値にReferenceを使えば x + y と記述できる  



## インライン(inline)とは

「3.2.1 具象型」で出てくるお話  



処理を高速化することができる(関数呼び出しの機械語が生成されない)  

クラス内で定義する関数はデフォルトでインライン化される  

// 今回クラス定義をcomplex.hで行ったため このヘッダで直接定義した関数はインライン関数  

inline指定子により クラス外で定義時にインライン化を指定できる  



## RAII(Resource Acquisition Is Initialization)とは

「3.2.1.2 コンテナ」で出てくるお話  

// コンテナ は 要素の集合(new double[s]など)を保持するオブジェクト を指す  



RAIIとは コンストラクタで資源を確保して デストラクタで解放する 技法のこと  

これにより "裸のnew/delete演算"が削減できる  

// 例えばVectorコンテナの要素を以下のように使う側でnewさせないってことだと認識  

// Vector v = Vector(1); v.elem = new double[s];  



